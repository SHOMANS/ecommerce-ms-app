name: Deploy to Production

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    environment: production
    timeout-minutes: 20

    env:
      EC2_HOST: ${{ secrets.EC2_HOST }}
      EC2_USER: ${{ secrets.EC2_USER }}
      EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate deployment secrets
        run: |
          if [ -z "${{ secrets.EC2_HOST }}" ] || [ -z "${{ secrets.EC2_USER }}" ] || [ -z "${{ secrets.EC2_PRIVATE_KEY }}" ]; then
            echo "‚ùå Missing required deployment secrets:"
            echo "   - EC2_HOST: ${{ secrets.EC2_HOST != '' && '‚úÖ Set' || '‚ùå Missing' }}"
            echo "   - EC2_USER: ${{ secrets.EC2_USER != '' && '‚úÖ Set' || '‚ùå Missing' }}"
            echo "   - EC2_PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY != '' && '‚úÖ Set' || '‚ùå Missing' }}"
            echo ""
            echo "üìù To configure deployment secrets:"
            echo "   1. Go to repository Settings > Secrets and variables > Actions"
            echo "   2. Add the following secrets:"
            echo "      - EC2_HOST: Your EC2 instance IP or domain"
            echo "      - EC2_USER: SSH username (usually 'ubuntu' or 'ec2-user')"
            echo "      - EC2_PRIVATE_KEY: Your private SSH key content"
            echo ""
            echo "‚ö†Ô∏è  Deployment will be skipped until secrets are configured."
            exit 0
          fi

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh

          # Write SSH key and ensure proper format
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/deploy_key.tmp

          # Remove any carriage returns and ensure proper line endings
          tr -d '\r' < ~/.ssh/deploy_key.tmp > ~/.ssh/deploy_key

          # Ensure the key starts and ends properly
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "‚ùå SSH key format appears invalid"
            echo "üîß Ensure your EC2_PRIVATE_KEY secret contains the full private key including:"
            echo "   -----BEGIN OPENSSH PRIVATE KEY-----"
            echo "   [key content]"
            echo "   -----END OPENSSH PRIVATE KEY-----"
            exit 1
          fi

          # Set proper permissions
          chmod 600 ~/.ssh/deploy_key

          # Test SSH key format
          echo "üîç Validating SSH key format..."
          ssh-keygen -l -f ~/.ssh/deploy_key || {
            echo "‚ùå SSH key validation failed"
            echo "üîß Please check that EC2_PRIVATE_KEY contains a valid OpenSSH private key"
            exit 1
          }

          # Add host to known_hosts
          echo "üîë Adding ${{ secrets.EC2_HOST }} to known hosts..."
          ssh-keyscan -t rsa,ecdsa,ed25519 -H "${{ secrets.EC2_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null || {
            echo "‚ö†Ô∏è  Could not add host to known_hosts, but continuing..."
          }

          # Test SSH connection
          echo "üîó Testing SSH connection..."
          ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection test failed"
            echo "üîß Troubleshooting tips:"
            echo "   1. Verify EC2_HOST is correct and accessible"
            echo "   2. Verify EC2_USER is correct (usually 'ubuntu', 'ec2-user', or 'admin')"
            echo "   3. Ensure the public key is added to ~/.ssh/authorized_keys on the EC2 instance"
            echo "   4. Check EC2 Security Groups allow SSH (port 22) from GitHub Actions IPs"
            echo "   5. Verify the private key matches the public key on the server"
            exit 1
          }

          # Clean up temporary file
          rm -f ~/.ssh/deploy_key.tmp

      - name: Deploy to EC2
        run: |
          echo "üöÄ Starting deployment to EC2..."

          # Use SSH with proper options to avoid pseudo-terminal issues
          ssh -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              -o ConnectTimeout=30 \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=3 \
              -i ~/.ssh/deploy_key \
              ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
              'bash -s' << 'ENDSSH'
            set -e
            
            echo "üîÑ Starting deployment on EC2 instance..."
            
            # Print diagnostic information
            echo "üîç Diagnostic information:"
            echo "   - Current user: $(whoami)"
            echo "   - Home directory: $HOME"
            echo "   - Current working directory: $(pwd)"
            echo "   - Available disk space: $(df -h . | tail -1)"
            
            # Ensure we start fresh - remove existing directory if it exists
            echo "üßπ Cleaning up existing project directory..."
            rm -rf ~/ecommerce-ms-app 2>/dev/null || true
            rm -rf /home/*/ecommerce-ms-app 2>/dev/null || true
            
            # Clone fresh repository
            echo "üìÅ Cloning fresh repository..."
            if ! git clone https://github.com/SHOMANS/ecommerce-ms-app.git ~/ecommerce-ms-app; then
              echo "‚ö†Ô∏è  Failed to clone to home directory, trying alternative location..."
              PROJECT_DIR="/tmp/ecommerce-ms-app-$(date +%s)"
              git clone https://github.com/SHOMANS/ecommerce-ms-app.git "$PROJECT_DIR"
              cd "$PROJECT_DIR"
            else
              cd ~/ecommerce-ms-app
            fi
            
            # Verify we're in the right directory and it's a git repository
            echo "ÔøΩ Current directory: $(pwd)"
            echo "üìÇ Repository status: $(git status --porcelain || echo 'Not a git repository')"
            
            # Stop current services
            echo "üõë Stopping current services..."
            if command -v docker-compose >/dev/null 2>&1; then
              docker-compose down --remove-orphans --timeout 30 2>/dev/null || true
            else
              docker compose down --remove-orphans --timeout 30 2>/dev/null || true
            fi
            
            # Cleanup old images and containers
            echo "üßπ Cleaning up old containers and images..."
            docker container prune -f 2>/dev/null || true
            docker image prune -f 2>/dev/null || true
            
            # Check if setup script exists
            if [ -f "scripts/setup-env.sh" ]; then
              echo "‚öôÔ∏è  Setting up production environment..."
              chmod +x scripts/setup-env.sh
              ./scripts/setup-env.sh prod
            else
              echo "‚ö†Ô∏è  Setup script not found, skipping environment setup"
            fi
            
            # Build and start new services
            echo "üèóÔ∏è  Building and starting services..."
            
            # Check if we have docker-compose or docker compose
            if command -v docker-compose >/dev/null 2>&1; then
              echo "üì¶ Using docker-compose command..."
              docker-compose up --build -d --remove-orphans
            elif docker compose version >/dev/null 2>&1; then
              echo "üì¶ Using docker compose command..."
              docker compose up --build -d --remove-orphans
            else
              echo "‚ùå Neither docker-compose nor docker compose found!"
              echo "üîß Installing docker-compose..."
              
              # Install docker-compose
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              
              echo "‚úÖ Docker-compose installed, starting services..."
              docker-compose up --build -d --remove-orphans
            fi
            
            # Wait for services to be ready
            echo "‚è≥ Waiting for services to start..."
            sleep 30
            
            # Check if services are running
            echo "üîç Checking container status..."
            if command -v docker-compose >/dev/null 2>&1; then
              docker-compose ps
            else
              docker compose ps
            fi
            
            # Test services with retry
            echo "üß™ Testing services..."
            for i in {1..5}; do
              if curl -f --connect-timeout 5 --max-time 10 http://localhost/health 2>/dev/null; then
                echo "‚úÖ Deployment successful - Services are running (attempt $i)"
                break
              else
                if [ $i -eq 5 ]; then
                  echo "‚ùå Deployment failed - Services are not responding after 5 attempts"
                  echo "üìã Container logs:"
                  if command -v docker-compose >/dev/null 2>&1; then
                    docker-compose logs --tail=20
                  else
                    docker compose logs --tail=20
                  fi
                  echo "üìä Container status:"
                  if command -v docker-compose >/dev/null 2>&1; then
                    docker-compose ps
                  else
                    docker compose ps
                  fi
                  exit 1
                fi
                echo "‚è≥ Services not ready yet, retrying in 10 seconds... (attempt $i/5)"
                sleep 10
              fi
            done
            
            echo "üéâ Deployment completed successfully!"
            echo "üìä Final container status:"
            if command -v docker-compose >/dev/null 2>&1; then
              docker-compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
            else
              docker compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
            fi
          ENDSSH

      - name: Health Check After Deployment
        run: |
          echo "üîç Checking service health after deployment..."

          # Additional wait to ensure services are ready
          echo "‚è≥ Waiting 30 seconds for services to stabilize..."
          sleep 30

          # Test services from external with retry logic
          echo "üåê Testing external connectivity..."
          MAX_ATTEMPTS=5
          ATTEMPT=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            if curl -f --connect-timeout 10 --max-time 30 http://${{ secrets.EC2_HOST }}/health; then
              echo "‚úÖ Services are running correctly from external!"
              break
            else
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "‚ùå Services not accessible from external after $MAX_ATTEMPTS attempts"
                echo "üîß Possible issues:"
                echo "   - Security Groups not configured (port 80/443)"
                echo "   - Services not fully started"
                echo "   - Network connectivity issues"
                exit 1
              fi
              echo "‚è≥ Retrying in 15 seconds..."
              sleep 15
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Deployment Notification
        if: always()
        run: |
          echo "üìä === DEPLOYMENT SUMMARY ==="
          echo "‚è∞ Time: $(date)"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üë§ Author: ${{ github.actor }}"
          echo ""

          if [ "${{ job.status }}" = "success" ]; then
            echo "üéâ DEPLOYMENT SUCCESSFUL!"
            echo "üåê Application URL: http://${{ secrets.EC2_HOST }}"
            echo "üîç Health Check: http://${{ secrets.EC2_HOST }}/health"
            echo "üìö API Docs: http://${{ secrets.EC2_HOST }}/api"
          else
            echo "‚ùå DEPLOYMENT FAILED!"
            echo "üîß Troubleshooting tips:"
            echo "   1. Check GitHub Actions logs for detailed error messages"
            echo "   2. Verify EC2 instance is running and accessible"
            echo "   3. Ensure Docker and Docker Compose are installed on EC2"
            echo "   4. Check Security Groups allow inbound traffic on port 80"
            echo "   5. Verify SSH key permissions and connectivity"
          fi
          echo "=========================="
