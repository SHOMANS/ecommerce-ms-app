name: Release Management

# Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥ØµØ¯Ø§Ø±Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©
on:
  push:
    branches: [main]
    paths:
      - "apps/**"
      - "packages/**"
      - "package.json"
      - "!**/*.md"

  workflow_dispatch:
    inputs:
      release_type:
        description: "Type of release"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major

env:
  REGISTRY: ghcr.io

jobs:
  # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¥ØµØ¯Ø§Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
  detect-changes:
    name: Detect Changes & Version Type
    runs-on: ubuntu-latest
    outputs:
      version_type: ${{ steps.version.outputs.type }}
      should_release: ${{ steps.version.outputs.should_release }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ” Analyze changes
        id: version
        run: |
          # ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ù„ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¥ØµØ¯Ø§Ø±
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
            echo "should_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # ÙØ­Øµ Ø§Ù„Ù€ commits Ù…Ù†Ø° Ø¢Ø®Ø± tag
          last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last tag: $last_tag"

          # Ø¬Ù…Ø¹ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù€ commits
          commits=$(git log ${last_tag}..HEAD --oneline --no-merges)
          echo "Recent commits:"
          echo "$commits"

          # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø­Ø³Ø¨ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©
          if echo "$commits" | grep -qi "BREAKING\|breaking change\|major"; then
            version_type="major"
          elif echo "$commits" | grep -qi "feat\|feature\|minor"; then
            version_type="minor"
          elif echo "$commits" | grep -qi "fix\|patch\|bugfix"; then
            version_type="patch"
          else
            version_type="patch"
          fi

          # Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ØªØºÙŠÙŠØ±Ø§Øª ØªØ³ØªØ­Ù‚ Ø¥ØµØ¯Ø§Ø±
          if [ -n "$commits" ]; then
            should_release="true"
          else
            should_release="false"
          fi

          echo "type=$version_type" >> $GITHUB_OUTPUT
          echo "should_release=$should_release" >> $GITHUB_OUTPUT

          echo "Detected version type: $version_type"
          echo "Should release: $should_release"

  # Ø¥Ù†Ø´Ø§Ø¡ Ø¥ØµØ¯Ø§Ø± Ø¬Ø¯ÙŠØ¯
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_release == 'true'
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: ğŸ“¦ Install dependencies
        run: |
          npm install -g pnpm
          pnpm install --frozen-lockfile

      - name: ğŸ”¢ Calculate new version
        id: version
        run: |
          # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
          current_version=$(node -p "require('./package.json').version")
          echo "Current version: $current_version"

          # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
          version_type="${{ needs.detect-changes.outputs.version_type }}"

          IFS='.' read -ra VERSION_PARTS <<< "$current_version"
          major=${VERSION_PARTS[0]}
          minor=${VERSION_PARTS[1]}
          patch=${VERSION_PARTS[2]}

          case $version_type in
            "major")
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            "minor")
              minor=$((minor + 1))
              patch=0
              ;;
            "patch")
              patch=$((patch + 1))
              ;;
          esac

          new_version="$major.$minor.$patch"
          echo "New version: $new_version"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT

      - name: ğŸ“ Update version in package.json
        run: |
          new_version="${{ steps.version.outputs.new_version }}"

          # ØªØ­Ø¯ÙŠØ« package.json Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
          npm version $new_version --no-git-tag-version

          # ØªØ­Ø¯ÙŠØ« Ø¥ØµØ¯Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø¯Ù…Ø§Øª
          cd apps/auth-service && npm version $new_version --no-git-tag-version
          cd ../users-service && npm version $new_version --no-git-tag-version
          cd ../../packages/shared && npm version $new_version --no-git-tag-version

      - name: ğŸ“‹ Generate changelog
        id: changelog
        run: |
          new_version="${{ steps.version.outputs.new_version }}"
          last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

          echo "# Changelog for v$new_version" > CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md
          echo "**Release Date:** $(date '+%Y-%m-%d')" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md

          # Ø¬Ù…Ø¹ Ø§Ù„Ù€ commits ÙˆØªØµÙ†ÙŠÙÙ‡Ø§
          echo "## ğŸš€ Features" >> CHANGELOG_TEMP.md
          git log ${last_tag}..HEAD --oneline --no-merges | grep -i "feat\|feature" | sed 's/^/- /' >> CHANGELOG_TEMP.md || echo "- No new features" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md

          echo "## ğŸ› Bug Fixes" >> CHANGELOG_TEMP.md
          git log ${last_tag}..HEAD --oneline --no-merges | grep -i "fix\|bugfix" | sed 's/^/- /' >> CHANGELOG_TEMP.md || echo "- No bug fixes" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md

          echo "## ğŸ”§ Improvements" >> CHANGELOG_TEMP.md
          git log ${last_tag}..HEAD --oneline --no-merges | grep -v -i "feat\|feature\|fix\|bugfix" | sed 's/^/- /' >> CHANGELOG_TEMP.md || echo "- No improvements" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md

          echo "## ğŸ“Š Statistics" >> CHANGELOG_TEMP.md
          echo "- **Commits:** $(git rev-list ${last_tag}..HEAD --count)" >> CHANGELOG_TEMP.md
          echo "- **Files changed:** $(git diff --name-only ${last_tag}..HEAD | wc -l)" >> CHANGELOG_TEMP.md
          echo "" >> CHANGELOG_TEMP.md

          cat CHANGELOG_TEMP.md

      - name: ğŸ’¾ Commit version changes
        run: |
          new_version="${{ steps.version.outputs.new_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .
          git commit -m "ğŸ”– Release v$new_version"
          git tag -a "v$new_version" -m "Release v$new_version"

          git push origin main
          git push origin "v$new_version"

      - name: ğŸš€ Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.version.outputs.new_version }}
          release_name: Release v${{ steps.version.outputs.new_version }}
          body_path: CHANGELOG_TEMP.md
          draft: false
          prerelease: false

  # Ø¨Ù†Ø§Ø¡ ÙˆÙ†Ø´Ø± Docker images Ù„Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
  build-and-publish:
    name: Build & Publish Release
    runs-on: ubuntu-latest
    needs: [detect-changes, create-release]
    if: needs.detect-changes.outputs.should_release == 'true'

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          ref: v${{ needs.create-release.outputs.new_version }}

      - name: ğŸ³ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ”‘ Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”§ Setup environment
        run: |
          chmod +x scripts/setup-env.sh
          ./scripts/setup-env.sh prod

      - name: ğŸ—ï¸ Build and tag images
        run: |
          version="${{ needs.create-release.outputs.new_version }}"

          # Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù€ images
          docker compose build

          # ØªØ³Ù…ÙŠØ© Ø§Ù„Ù€ images Ø¨Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
          docker tag ecommerce-ms-app_auth-service ${{ env.REGISTRY }}/${{ github.repository_owner }}/auth-service:v$version
          docker tag ecommerce-ms-app_users-service ${{ env.REGISTRY }}/${{ github.repository_owner }}/users-service:v$version

          # ØªØ³Ù…ÙŠØ© ÙƒÙ€ latest Ø£ÙŠØ¶Ø§Ù‹
          docker tag ecommerce-ms-app_auth-service ${{ env.REGISTRY }}/${{ github.repository_owner }}/auth-service:latest
          docker tag ecommerce-ms-app_users-service ${{ env.REGISTRY }}/${{ github.repository_owner }}/users-service:latest

      - name: ğŸ“¤ Push images
        run: |
          version="${{ needs.create-release.outputs.new_version }}"

          # Ø±ÙØ¹ Ø§Ù„Ù€ images
          docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/auth-service:v$version
          docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/users-service:v$version
          docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/auth-service:latest
          docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/users-service:latest

          echo "ğŸ‰ Successfully published images for version v$version"

  # Ø¥Ø´Ø¹Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­ Ø§Ù„Ø¥ØµØ¯Ø§Ø±
  notify-release:
    name: Notify Release Success
    runs-on: ubuntu-latest
    needs: [create-release, build-and-publish]
    if: always() && needs.create-release.result == 'success'

    steps:
      - name: ğŸ“¢ Success notification
        run: |
          version="${{ needs.create-release.outputs.new_version }}"
          echo "ğŸ‰ Successfully released version v$version!"
          echo "ğŸ“¦ Docker images published to registry"
          echo "ğŸ”— Release notes: https://github.com/${{ github.repository }}/releases/tag/v$version"
